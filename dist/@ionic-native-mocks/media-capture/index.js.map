{"version":3,"sources":["../../../src/@ionic-native-mocks/plugins/media-capture/index.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,6BAA6B,CAAC;AAC3D,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAsG7C;IAAsC,oCAAY;IAAlD;;IAuEA,CAAC;IAvDG;;;;OAIG;IACH,uCAAY,GAAZ,UAAa,OAA6B;QACtC,IAAI,QAAQ,GAAqB,EAAE,CAAC;QACpC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,uCAAY,GAAZ,UAAa,OAA6B;QACtC,IAAI,QAAQ,GAAqB,EAAE,CAAC;QACpC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,uCAAY,GAAZ,UAAa,OAA6B;QACtC,IAAI,QAAQ,GAAqB,EAAE,CAAC;QACpC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;OAGG;IACH,iDAAsB,GAAtB;QACI,IAAI,QAAQ,GAAqB,EAAE,CAAC;QACpC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,UAAC,QAAuB;YAC7C,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACxB,QAAQ,CAAC,QAAQ,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;OAGG;IACH,gDAAqB,GAArB;QACI,IAAI,QAAQ,GAAqB,EAAE,CAAC;QACpC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,UAAC,QAAuB;YAC7C,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACxB,QAAQ,CAAC,QAAQ,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACN,uBAAC;AAAD,CAvEA,AAuEC,CAvEqC,YAAY,GAuEjD","file":"index.js","sourceRoot":"","sourcesContent":["import { MediaCapture } from '@ionic-native/media-capture';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport { Observer } from 'rxjs/Observer';\r\n\r\nexport interface MediaFile {\r\n    /**\r\n     * The name of the file, without path information.\r\n     */\r\n    name: string;\r\n    /**\r\n     * The full path of the file, including the name.\r\n     */\r\n    fullPath: string;\r\n    /**\r\n     * The file's mime type\r\n     */\r\n    type: string;\r\n    /**\r\n     * The date and time when the file was last modified.\r\n     */\r\n    lastModifiedDate: Date;\r\n    /**\r\n     * The size of the file, in bytes.\r\n     */\r\n    size: number;\r\n    /**\r\n     * Retrieves the format information of the media file.\r\n     * @param {Function} successCallback\r\n     * @param {Function} errorCallback\r\n     */\r\n    getFormatData(successCallback: (data: MediaFileData) => any, errorCallback?: (err: any) => any): void;\r\n}\r\nexport interface MediaFileData {\r\n    /**\r\n     * The actual format of the audio and video content.\r\n     */\r\n    codecs: string;\r\n    /**\r\n     * The average bitrate of the content. The value is zero for images.\r\n     */\r\n    bitrate: number;\r\n    /**\r\n     * The height of the image or video in pixels. The value is zero for audio clips.\r\n     */\r\n    height: number;\r\n    /**\r\n     * The width of the image or video in pixels. The value is zero for audio clips.\r\n     */\r\n    width: number;\r\n    /**\r\n     * The length of the video or sound clip in seconds. The value is zero for images.\r\n     */\r\n    duration: number;\r\n}\r\nexport interface CaptureError {\r\n    code: string;\r\n}\r\nexport interface CaptureAudioOptions {\r\n    /**\r\n     * Maximum number of audio clips. Defaults to 1.\r\n     * On iOS you can only record one file.\r\n     */\r\n    limit?: number;\r\n    /**\r\n     * Maximum duration of an audio sound clip, in seconds. This does not work on Android devices.\r\n     */\r\n    duration?: number;\r\n}\r\nexport interface CaptureImageOptions {\r\n    /**\r\n     * Maximum number of images to capture. This limit is not supported on iOS, only one image will be taken per invocation.\r\n     */\r\n    limit?: number;\r\n}\r\nexport interface CaptureVideoOptions {\r\n    /**\r\n     * Maximum number of video clips to record. This value is ignored on iOS, only one video clip can be taken per invocation.\r\n     */\r\n    limit?: number;\r\n    /**\r\n     * Maximum duration per video clip. This will be ignored on BlackBerry.\r\n     */\r\n    duration?: number;\r\n    /**\r\n     * Quality of the video. This parameter can only be used with Android.\r\n     */\r\n    quality?: number;\r\n}\r\nexport interface ConfigurationData {\r\n    /**\r\n     * The ASCII-encoded lowercase string representing the media type.\r\n     */\r\n    type: string;\r\n    /**\r\n     * The height of the image or video in pixels. The value is zero for sound clips.\r\n     */\r\n    height: number;\r\n    /**\r\n     * The width of the image or video in pixels. The value is zero for sound clips.\r\n     */\r\n    width: number;\r\n}\r\n\r\nexport class MediaCaptureMock extends MediaCapture {\r\n    /**\r\n     * The recording image sizes and formats supported by the device.\r\n     * @returns {ConfigurationData[]}\r\n     */\r\n    supportedImageModes: ConfigurationData[];\r\n    /**\r\n     * The audio recording formats supported by the device.\r\n     * @returns {ConfigurationData[]}\r\n     */\r\n    supportedAudioModes: ConfigurationData[];\r\n    /**\r\n     * The recording video resolutions and formats supported by the device.\r\n     * @returns {ConfigurationData[]}\r\n     */\r\n    supportedVideoModes: ConfigurationData[];\r\n    /**\r\n     * Start the audio recorder application and return information about captured audio clip files.\r\n     * @param options\r\n     * @returns {Promise<MediaFile[]>}\r\n     */\r\n    captureAudio(options?: CaptureAudioOptions): Promise<MediaFile[] | CaptureError> {\r\n        let response: Array<MediaFile> = [];\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Start the camera application and return information about captured image files.\r\n     * @param options\r\n     * @returns {Promise<MediaFile[]>}\r\n     */\r\n    captureImage(options?: CaptureImageOptions): Promise<MediaFile[] | CaptureError> {\r\n        let response: Array<MediaFile> = [];\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Start the video recorder application and return information about captured video clip files.\r\n     * @param options\r\n     * @returns {Promise<MediaFile[]>}\r\n     */\r\n    captureVideo(options?: CaptureVideoOptions): Promise<MediaFile[] | CaptureError> {\r\n        let response: Array<MediaFile> = [];\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * is fired if the capture call is successful\r\n     * @returns {Observable<MediaFile[]>}\r\n     */\r\n    onPendingCaptureResult(): Observable<MediaFile[]> {\r\n        let response: Array<MediaFile> = [];\r\n        return Observable.create((observer: Observer<any>) => {\r\n            observer.next(response);\r\n            observer.complete();\r\n        });\r\n    };\r\n    /**\r\n     * is fired if the capture call is unsuccessful\r\n     * @returns {Observable<CaptureError>}\r\n     */\r\n    onPendingCaptureError(): Observable<CaptureError> {\r\n        let response: Array<MediaFile> = [];\r\n        return Observable.create((observer: Observer<any>) => {\r\n            observer.next(response);\r\n            observer.complete();\r\n        });\r\n    };\r\n}\r\n"]}