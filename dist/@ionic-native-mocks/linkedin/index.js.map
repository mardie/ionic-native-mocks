{"version":3,"sources":["../../../src/@ionic-native-mocks/plugins/linkedin/index.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,wBAAwB,CAAC;AAIlD;IAAkC,gCAAQ;IAA1C;;IAkEA,CAAC;IAjEG;;;;;OAKG;IACH,4BAAK,GAAL,UAAM,MAA6B,EAAE,eAAwB;QACzD,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;OAEG;IACH,6BAAM,GAAN,cAAgB,CAAC;IAAA,CAAC;IAClB;;;;OAIG;IACH,iCAAU,GAAV,UAAW,IAAY;QACnB,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;;OAKG;IACH,kCAAW,GAAX,UAAY,IAAY,EAAE,IAAS;QAC/B,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;;OAIG;IACH,kCAAW,GAAX,UAAY,QAAgB;QACxB,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;OAGG;IACH,uCAAgB,GAAhB;QACI,IAAI,QAAQ,GAAY,IAAI,CAAC;QAC7B,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACF;;;OAGG;IACH,uCAAgB,GAAhB;QACI,MAAM,CAAC,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,OAAO,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACP,CAAC;IAAA,CAAC;IACN,mBAAC;AAAD,CAlEA,AAkEC,CAlEiC,QAAQ,GAkEzC","file":"index.js","sourceRoot":"","sourcesContent":["import { LinkedIn } from '@ionic-native/linkedin';\r\n\r\nexport declare type LinkedInLoginScopes = 'r_basicprofile' | 'r_emailaddress' | 'rw_company_admin' | 'w_share';\r\n\r\nexport class LinkedInMock extends LinkedIn {\r\n    /**\r\n     * Login with the LinkedIn App\r\n     * @param scopes {string[]} Scopes to authorize\r\n     * @param promptToInstall {boolean} set to true to prompt the user to download the LinkedIn app if it's not installed\r\n     * @return {Promise<any>}\r\n     */\r\n    login(scopes: LinkedInLoginScopes[], promptToInstall: boolean): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Clears the current session\r\n     */\r\n    logout(): void {};\r\n    /**\r\n     * Make a get request\r\n     * @param path {string} request path\r\n     * @return {Promise<any>}\r\n     */\r\n    getRequest(path: string): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Make a post request\r\n     * @param path {string} request path\r\n     * @param body {Object} request body\r\n     * @return {Promise<any>}\r\n     */\r\n    postRequest(path: string, body: any): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Opens a member's profile\r\n     * @param memberId {string} Member id\r\n     * @return {Promise<any>}\r\n     */\r\n    openProfile(memberId: string): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Checks if there is already an existing active session. This should be used to avoid unnecessary login.\r\n     * @return {Promise<boolean>} returns a promise that resolves with a boolean that indicates whether there is an active session\r\n     */\r\n    hasActiveSession(): Promise<boolean> {\r\n        let response: boolean = true;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Checks if there is an active session and returns the access token if it exists.\r\n     * @return {Promise<any>} returns a promise that resolves with an object that contains an access token if there is an active session\r\n     */\r\n    getActiveSession(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n}\r\n"]}