{"version":3,"sources":["../../../src/@ionic-native-mocks/plugins/ibeacon/index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"","sourcesContent":["import { IBeacon } from '@ionic-native/ibeacon';\r\nimport { Observable } from 'rxjs/Observable';\r\n\r\nexport interface Beacon {\r\n    /**\r\n     * The physical device's identifier.\r\n     */\r\n    uuid: string;\r\n    /**\r\n     * The beacon's major identifier number.\r\n     */\r\n    major: number;\r\n    /**\r\n     * The beacon's minor identifier number.\r\n     */\r\n    minor: number;\r\n    /**\r\n     * The proximity of the beacon relative to the phone.\r\n     *\r\n     * Possible options are:\r\n     * ProximityImmediate\r\n     * ProximityNear\r\n     * ProximityFar\r\n     * ProximityUnknown\r\n     */\r\n    proximity: 'ProximityImmediate' | 'ProximityNear' | 'ProximityFar' | 'ProximityUnknown';\r\n    /**\r\n     * Transmission Power of the beacon. A constant emitted by the beacon which indicates what's the expected RSSI at a distance of 1 meter to the beacon.\r\n     */\r\n    tx: number;\r\n    /**\r\n     * Received Signal Strength Indicator. The strength of the beacon's signal when it reaches the device.\r\n     *  RSSI ranges from aprox -26 (a few inches) to -100 (40-50 m distance).\r\n     */\r\n    rssi: number;\r\n    /**\r\n     * The accuracy of the ranging.\r\n     */\r\n    accuracy: number;\r\n}\r\nexport interface BeaconRegion {\r\n    /**\r\n     * A unique identifier for this region.\r\n     */\r\n    identifier: string;\r\n    /**\r\n     * The the beacon identifier the device will \"watch\" for. Many beacons can share the same uuid.\r\n     */\r\n    uuid: string;\r\n    /**\r\n     * The beacon's major identifier number. Optional, of nothing is supplied\r\n     * the plugin will treat it as a wildcard.\r\n     */\r\n    major?: number;\r\n    /**\r\n     * The beacon's minor identifier number. Optional, of nothing is supplied\r\n     * the plugin will treat it as a wildcard.\r\n     */\r\n    minor?: number;\r\n    /**\r\n     * If set to true the device will scan for beacons and determine region state anytime\r\n     * the device's screen is turned on or off. Useful for debugging.\r\n     */\r\n    notifyEntryStateOnDisplay?: boolean;\r\n}\r\nexport interface CircularRegion {\r\n    /**\r\n     * A unique identifier for this region.\r\n     */\r\n    identifier: string;\r\n    /**\r\n     * The latitude of this region.\r\n     */\r\n    latitude: number;\r\n    /**\r\n     * The longitude of this region.\r\n     */\r\n    longitude: number;\r\n    /**\r\n     * The radius of the geofence for this region.\r\n     */\r\n    radius: number;\r\n}\r\nexport declare type Region = BeaconRegion | CircularRegion;\r\nexport interface IBeaconPluginResult {\r\n    /**\r\n     * The name of the delegate function that produced the PluginResult object.\r\n     */\r\n    eventType: string;\r\n    /**\r\n     * The region that triggered the event.\r\n     */\r\n    region: Region;\r\n    /**\r\n     * An array of beacon objects\r\n     */\r\n    beacons: Beacon[];\r\n    /**\r\n     * The status of the location permission for iOS.\r\n     */\r\n    authorizationStatus: string;\r\n    /**\r\n     * The state of the phone in relation to the region. Inside/outside for example.\r\n     */\r\n    state: 'CLRegionStateInside' | 'CLRegionStateOutside';\r\n    /**\r\n     * Error message, used only with monitoringDidFailForRegionWithError delegate.\r\n     */\r\n    error: string;\r\n}\r\nexport interface IBeaconDelegate {\r\n    /**\r\n     * An observable that publishes information about the location permission authorization status.\r\n     *\r\n     * @returns {Observable<string>} Returns a string.\r\n     */\r\n    didChangeAuthorizationStatus(): Observable<string>;\r\n    /**\r\n     * An Observable that publishes event data to it's subscribers\r\n     * when the native layer is able to determine the device's state.\r\n     *\r\n     * This event is called when the phone begins starts monitoring,\r\n     * when requestStateForRegion is called, etc.\r\n     *\r\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\r\n     */\r\n    didDetermineStateForRegion(): Observable<IBeaconPluginResult>;\r\n    /**\r\n     * An Observable that publishes event data to it's subscribers\r\n     * when the phone enters a region that it was asked to monitor.\r\n     *\r\n     * If the user has given the app Always-Location permission, this function\r\n     *  will be called even when the app is not running on iOS.\r\n     * The app will run silently in the background for a small amount of time.\r\n     *\r\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\r\n     */\r\n    didEnterRegion(): Observable<IBeaconPluginResult>;\r\n    /**\r\n     * An Observable that publishes event data to it's subscribers\r\n     * when the phone exits a region that it was asked to monitor.\r\n     *\r\n     * If the user has given the app Always-Location permission, this function\r\n     *  will be called even when the app is not running on iOS.\r\n     * The app will run silently in the background for a small amount of time.\r\n     *\r\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\r\n     */\r\n    didExitRegion(): Observable<IBeaconPluginResult>;\r\n    /**\r\n     * An Observable that publishes event data to it's subscribers\r\n     *  each time that the device ranges beacons. Modern Android and iOS devices range\r\n     * aproximately once per second.\r\n     *\r\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\r\n     */\r\n    didRangeBeaconsInRegion(): Observable<IBeaconPluginResult>;\r\n    /**\r\n     * An Observable that publishes event data to it's subscribers\r\n     *  when the device begins monitoring a region.\r\n     *\r\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\r\n     */\r\n    didStartMonitoringForRegion(): Observable<IBeaconPluginResult>;\r\n    /**\r\n     * An Observable that publishes event data to it's subscribers\r\n     *  when the device fails to monitor a region.\r\n     *\r\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\r\n     */\r\n    monitoringDidFailForRegionWithError(): Observable<IBeaconPluginResult>;\r\n    /**\r\n     * An Observable that publishes event data to it's subscribers\r\n     *  when the device begins advertising as an iBeacon.\r\n     *\r\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\r\n     */\r\n    peripheralManagerDidStartAdvertising(): Observable<IBeaconPluginResult>;\r\n    /**\r\n     * An Observable that publishes event data to it's subscribers\r\n     * when the state of the peripheral manager's state updates.\r\n     *\r\n     *\r\n     * @returns {Observable<IBeaconPluginResult>} Returns a IBeaconPluginResult object with information about the event, region, and beacon(s).\r\n     */\r\n    peripheralManagerDidUpdateState(): Observable<IBeaconPluginResult>;\r\n}\r\n\r\nexport class IBeaconMock extends IBeacon {\r\n    /**\r\n     * Instances of this class are delegates between the {@link LocationManager} and\r\n     * the code that consumes the messages generated on in the native layer.\r\n     *\r\n     * @returns {IBeaconDelegate} An instance of the type {@type Delegate}.\r\n     */\r\n    Delegate(): IBeaconDelegate {\r\n        let response: IBeaconDelegate;\r\n        return response;\r\n    };\r\n    /**\r\n     * Creates a new BeaconRegion\r\n     *\r\n     * @param {String} identifier @see {CLRegion}\r\n     * @param {String} uuid The proximity ID of the beacon being targeted.\r\n     * This value must not be blank nor invalid as a UUID.\r\n     * @param {Number} major The major value that you use to identify one or more beacons.\r\n     * @param {Number} minor The minor value that you use to identify a specific beacon.\r\n     * @param {BOOL} notifyEntryStateOnDisplay\r\n     *\r\n     * @returns {BeaconRegion} Returns the BeaconRegion that was created\r\n     */\r\n    BeaconRegion(identifer: string, uuid: string, major?: number, minor?: number, notifyEntryStateOnDisplay?: boolean): BeaconRegion {\r\n        let response: BeaconRegion;\r\n        return response;\r\n    };\r\n    /**\r\n     * @returns {IBeaconDelegate} Returns the IBeaconDelegate\r\n     */\r\n    getDelegate(): IBeaconDelegate {\r\n        let response: IBeaconDelegate;\r\n        return response;\r\n    };\r\n    /**\r\n     * @param {IBeaconDelegate} delegate An instance of a delegate to register with the native layer.\r\n     *\r\n     * @returns {IBeaconDelegate} Returns the IBeaconDelegate\r\n     */\r\n    setDelegate(delegate: IBeaconDelegate): IBeaconDelegate {\r\n        let response: IBeaconDelegate;\r\n        return response;\r\n    };\r\n    /**\r\n     * Signals the native layer that the client side is ready to consume messages.\r\n     * Readiness here means that it has a {IBeaconDelegate} set by the consumer javascript\r\n     * code.\r\n     *\r\n     * The {LocationManager.setDelegate()} will implicitly call this method as well,\r\n     * therefore the only case when you have to call this manually is if you don't\r\n     * wish to specify a {IBeaconDelegate} of yours.\r\n     *\r\n     * The purpose of this signaling mechanism is to make the events work when the\r\n     * app is being woken up by the Operating System to give it a chance to handle\r\n     * region monitoring events for example.\r\n     *\r\n     * If you don't set a {IBeaconDelegate} and don't call this method manually, an error\r\n     * message get emitted in the native runtime and the DOM as well after a certain\r\n     * period of time.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer acknowledged the request and started to send events.\r\n     */\r\n    onDomDelegateReady(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Determines if bluetooth is switched on, according to the native layer.\r\n     * @returns {Promise<boolean>} Returns a promise which is resolved with a {Boolean}\r\n     * indicating whether bluetooth is active.\r\n     */\r\n    isBluetoothEnabled(): Promise<boolean> {\r\n        let response: boolean = true;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Enables Bluetooth using the native Layer. (ANDROID ONLY)\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved when Bluetooth\r\n     * could be enabled. If not, the promise will be rejected with an error.\r\n     */\r\n    enableBluetooth(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Disables Bluetooth using the native Layer. (ANDROID ONLY)\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved when Bluetooth\r\n     * could be enabled. If not, the promise will be rejected with an error.\r\n     */\r\n    disableBluetooth(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Start monitoring the specified region.\r\n     *\r\n     * If a region of the same type with the same identifier is already being\r\n     * monitored for this application,\r\n     * it will be removed from monitoring. For circular regions, the region\r\n     * monitoring service will prioritize\r\n     * regions by their size, favoring smaller regions over larger regions.\r\n     *\r\n     * This is done asynchronously and may not be immediately reflected in monitoredRegions.\r\n     *\r\n     * @param {Region} region An instance of {Region} which will be monitored\r\n     * by the operating system.\r\n     *\r\n     * @returns {Promise<string>} Returns a promise which is resolved as soon as the\r\n     * native layer acknowledged the dispatch of the monitoring request.\r\n     */\r\n    startMonitoringForRegion(region: BeaconRegion): Promise<string> {\r\n        let response: string = '';\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Stop monitoring the specified region.  It is valid to call\r\n     * stopMonitoringForRegion: for a region that was registered for monitoring\r\n     * with a different location manager object, during this or previous\r\n     * launches of your application.\r\n     *\r\n     * This is done asynchronously and may not be immediately reflected in monitoredRegions.\r\n     *\r\n     * @param {Region} region An instance of {Region} which will be monitored\r\n     * by the operating system.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer acknowledged the dispatch of the request to stop monitoring.\r\n     */\r\n    stopMonitoringForRegion(region: BeaconRegion): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Request state the for specified region. When result is ready\r\n     * didDetermineStateForRegion is triggered. This can be any region,\r\n     * also those which is not currently monitored.\r\n     *\r\n     * This is done asynchronously and may not be immediately reflected in monitoredRegions.\r\n     *\r\n     * @param {Region} region An instance of {Region} which will be monitored\r\n     * by the operating system.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer acknowledged the dispatch of the request to stop monitoring.\r\n     */\r\n    requestStateForRegion(region: Region): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Start ranging the specified beacon region.\r\n     *\r\n     * If a region of the same type with the same identifier is already being\r\n     * monitored for this application, it will be removed from monitoring.\r\n     *\r\n     * This is done asynchronously and may not be immediately reflected in rangedRegions.\r\n     *\r\n     * @param {Region} region An instance of {BeaconRegion} which will be monitored\r\n     * by the operating system.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer acknowledged the dispatch of the monitoring request.\r\n     */\r\n    startRangingBeaconsInRegion(region: BeaconRegion): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Stop ranging the specified region.  It is valid to call\r\n     * stopMonitoringForRegion: for a region that was registered for ranging\r\n     * with a different location manager object, during this or previous\r\n     * launches of your application.\r\n     *\r\n     * This is done asynchronously and may not be immediately reflected in rangedRegions.\r\n     *\r\n     * @param {Region} region An instance of {BeaconRegion} which will be monitored\r\n     * by the operating system.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer acknowledged the dispatch of the request to stop monitoring.\r\n     */\r\n    stopRangingBeaconsInRegion(region: BeaconRegion): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Queries the native layer to determine the current authorization in effect.\r\n     *\r\n     * @returns {Promise<IBeaconPluginResult>} Returns a promise which is resolved with the\r\n     * requested authorization status.\r\n     */\r\n    getAuthorizationStatus(): Promise<IBeaconPluginResult> {\r\n        let response: IBeaconPluginResult;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * For iOS 8 and above only. The permission model has changed by Apple in iOS 8, making it necessary for apps to\r\n     * explicitly request permissions via methods like these:\r\n     * <a href=\"https://developer.apple.com/library/prerelease/iOS/documentation/CoreLocation/Reference/CLLocationManager_Class/index.html#//apple_ref/occ/instm/CLLocationManager/requestWhenInUseAuthorization\">requestWhenInUseAuthorization</a>\r\n     * <a href=\"https://developer.apple.com/library/prerelease/iOS/documentation/CoreLocation/Reference/CLLocationManager_Class/index.html#//apple_ref/occ/instm/CLLocationManager/requestAlwaysAuthorization\">requestAlwaysAuthorization</a>\r\n     *\r\n     * If you are using this plugin on Android devices only, you will never have to use this, nor {@code requestAlwaysAuthorization}\r\n     * @returns {Promise<any>} Returns a promise that is resolved when the request dialog is shown.\r\n     */\r\n    requestWhenInUseAuthorization(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * See the documentation of {@code requestWhenInUseAuthorization} for further details.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved when the native layer\r\n     * shows the request dialog.\r\n     */\r\n    requestAlwaysAuthorization(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     *\r\n     * @returns {Promise<Region[]>} Returns a promise which is resolved with an {Array}\r\n     * of {Region} instances that are being monitored by the native layer.\r\n     */\r\n    getMonitoredRegions(): Promise<Region[]> {\r\n        let response: Array<Region> = [];\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     *\r\n     * @returns {Promise<Region[]>} Returns a promise which is resolved with an {Array}\r\n     * of {Region} instances that are being ranged by the native layer.\r\n     */\r\n    getRangedRegions(): Promise<Region[]> {\r\n        let response: Array<Region> = [];\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Determines if ranging is available or not, according to the native layer.\r\n     * @returns {Promise<boolean>} Returns a promise which is resolved with a {Boolean}\r\n     * indicating whether ranging is available or not.\r\n     */\r\n    isRangingAvailable(): Promise<boolean> {\r\n        let response: boolean = true;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Determines if region type is supported or not, according to the native layer.\r\n     *\r\n     * @param {Region} region An instance of {Region} which will be checked\r\n     * by the operating system.\r\n     *\r\n     * @returns {Promise<boolean>} Returns a promise which is resolved with a {Boolean}\r\n     * indicating whether the region type is supported or not.\r\n     */\r\n    isMonitoringAvailableForClass(region: Region): Promise<boolean> {\r\n        let response: boolean = true;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Start advertising the specified region.\r\n     *\r\n     * If a region a different identifier is already being advertised for\r\n     * this application, it will be replaced with the new identifier.\r\n     *\r\n     * This call will accept a valid beacon even when no BlueTooth is available,\r\n     * and will start when BlueTooth is powered on. See {IBeaconDelegate.}\r\n     *\r\n     * @param {Region} region An instance of {Region} which will be advertised\r\n     * by the operating system.\r\n     * @param {Integer} measuredPower: Optional parameter, if left empty, the device will\r\n     * use it's own default value.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer acknowledged the dispatch of the advertising request.\r\n     */\r\n    startAdvertising(region: Region, measuredPower?: number): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Stop advertising as a beacon.\r\n     *\r\n     * This is done asynchronously and may not be immediately reflected in isAdvertising.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer acknowledged the dispatch of the request to stop advertising.\r\n     */\r\n    stopAdvertising(region: Region): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Determines if advertising is available or not, according to the native layer.\r\n     * @returns {Promise<any>} Returns a promise which is resolved with a {Boolean}\r\n     * indicating whether advertising is available or not.\r\n     */\r\n    isAdvertisingAvailable(): Promise<boolean> {\r\n        let response: boolean = true;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Determines if advertising is currently active, according to the native layer.\r\n     * @returns {Promise<any>} Returns a promise which is resolved with a {Boolean}\r\n     * indicating whether advertising is active.\r\n     */\r\n    isAdvertising(): Promise<boolean> {\r\n        let response: boolean = true;\r\n        return new Promise((resolve, reject) => {\r\n            resolve(response);\r\n        });\r\n    };\r\n    /**\r\n     * Disables debug logging in the native layer. Use this method if you want\r\n     * to prevent this plugin from writing to the device logs.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer has set the logging level accordingly.\r\n     */\r\n    disableDebugLogs(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Enables the posting of debug notifications in the native layer. Use this method if you want\r\n     * to allow the plugin the posting local notifications.\r\n     * This can be very helpful when debugging how to apps behave when launched into the background.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer has set the flag to enabled.\r\n     */\r\n    enableDebugNotifications(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Disables the posting of debug notifications in the native layer. Use this method if you want\r\n     * to prevent the plugin from posting local notifications.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer has set the flag to disabled.\r\n     */\r\n    disableDebugNotifications(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Enables debug logging in the native layer. Use this method if you want\r\n     * a debug the inner workings of this plugin.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved as soon as the\r\n     * native layer has set the logging level accordingly.\r\n     */\r\n    enableDebugLogs(): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n    /**\r\n     * Appends the provided [message] to the device logs.\r\n     * Note: If debug logging is turned off, this won't do anything.\r\n     *\r\n     * @param {String} message The message to append to the device logs.\r\n     *\r\n     * @returns {Promise<any>} Returns a promise which is resolved with the log\r\n     * message received by the native layer for appending. The returned message\r\n     * is expected to be equivalent to the one provided in the original call.\r\n     */\r\n    appendToDeviceLog(message: string): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            resolve();\r\n        });\r\n    };\r\n}\r\n"]}